TODO
====

. Split test executer from overall test manager

. Do test-sugo-1.c

. DONE Implement input/output redirection for each test
.. test for errors
... errno
.. open input without following symbolic links
... if file does not exist, create for now
... in future, it will be specified using a configuration file, so we will take care of that then.
.. open output only if does not exit: creat()?
... NO symlink
.. All inputs and outputs should be placed in directory with random name so multiple runs do not share outputs (nor inputs...)
... combination of PID and random:
... print out its location

. Print statistics at the end: time too?

. Signals? DUring test, try delay and see if signal propagates

. Process handling: process groups? Signals?
.. priority?

. Improve test to allow configuration file to check test
.. and set umask
.. and file names
.. and limits
.. and other things too...
.. arguments
.. env variables

. What about a communications channel with sugo? Somewhere a test can use to communicate with sugo other than signals.
.. Maybe can be used to provide some kind of support for tests, without affecting the test's process space: a file descriptor is not a library to be linked against or anything, and can work out better... maybe?

. File notification of activity to monitor processes...

. Determine if test is stuck with timer

. Printout on stderr/stdout: stdout is user friendly for now
.. in future, use porcelain to make output interpretable by script

. Debug output: for optimising Sugo itself:
.. was an out of sequence process terminated? how many of the total?

. implement system programs and all about networking, synchronizing threads etc...
.. as tests for sugo

. study structured computer organization
.. to the point of learning assembler basics
.. Then learn assembler i386

. Generic data structures from CINI

. Issue with fork/exec:
.. We don't check if the file to exec actually exists and is executable before we fork.
	This means we never really get pending tests not being executed: if a test is not executed, the process aborts and writes why to stderr.
	If we can't fork, we move onto execution and leave the pending ones behind. But that's if we couldn't fork.
	The problem is that if we mispelt some tests, we only know because of an abort.
	I guess time will tell and we'll have to deal with it.
	As far as I know, it's only relevant once in use and we print stats, so I think we should concentrate on that instead.
	For now, if a test is not found we leave it to the exec to figure that out.
	But in the future we might need to do it ourselves.

. finish unit tests for tests.o
.. need to extensively test sugo's internal
... running tests and completed tests
.. self testing is also useful
... test sugo itself: input and output

. Write tutorial online: how to use

. Write manual page

. Write architecture document: how to hack

